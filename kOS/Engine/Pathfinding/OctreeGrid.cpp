/******************************************************************/
/*!
\file      OctreeGrid.cpp
\author    Yeo See Kiat Raymond, seekiatraymond.yeo, 2301268
\par       seekiatraymond.yeo@digipen.edu
\date      October 3, 2025
\brief     This file contains the grid generated by the Octree system,
			holding the graph to be accessed and determines how the
			octree should be created.


Copyright (C) 2025 DigiPen Institute of Technology.
Reproduction or disclosure of this file or its contents without the
prior written consent of DigiPen Institute of Technology is prohibited.
*/
/********************************************************************/

#include "OctreeGrid.h"

namespace Octrees {
	Octree::Octree() {

	}

	Octree::Octree(float minNodeSize, Graph _graph) {
		graph = _graph;

		graph.nodes.reserve(1000);

		CalculateBounds();
		CreateTree(minNodeSize);
		GetEmptyLeaves(&root);

		GetEdges();
	}

	void Octree::GetEmptyLeaves(OctreeNode* node) {
		if (node->IsLeaf() && !node->objects.size()) {
			emptyLeaves.push_back(*node);
			graph.AddNode(*node);

			return;
		}

		if (node->children.empty()) {
			return;
		}

		for (OctreeNode& child : node->children) {
			GetEmptyLeaves(&child);
		}

		for (int i = 0; i < node->children.size(); ++i) {
			for (int j = i + 1; j < node->children.size(); ++j) {
				if (i == j)
					continue;

				graph.AddEdge(&node->children[i], &node->children[j]);
			}
		}
	}

	void Octree::CreateTree(float minNodeSize) {
		ecs::ECS* ecs = ecs::ECS::GetInstance();
		root = OctreeNode(bounds, minNodeSize);
		for (const auto& id : ecs->GetEntitySignatureData()) {
			ecs::BoxColliderComponent* boxCollider = ecs->GetComponent<ecs::BoxColliderComponent>(id.first);
			ecs::NameComponent* name = ecs->GetComponent<ecs::NameComponent>(id.first);

			if (!boxCollider)
				continue;

			if (ecs->GetComponent<ecs::PathfinderComponent>(id.first) || ecs->GetComponent<ecs::PathfinderTargetComponent>(id.first))
				continue;

			root.Divide(id.first);
		}
	}

	void Octree::CalculateBounds() {
		ecs::ECS* ecs = ecs::ECS::GetInstance();
		glm::vec3 minBound(std::numeric_limits<float>::max(), std::numeric_limits<float>::max(), std::numeric_limits<float>::max()),
			maxBound(std::numeric_limits<float>::lowest(), std::numeric_limits<float>::lowest(), std::numeric_limits<float>::lowest());

		glm::vec3 boundCenter(0.f, 0.f, 0.f);
		for (const auto& id : ecs->GetEntitySignatureData()) {
			ecs::BoxColliderComponent* boxCollider = ecs->GetComponent<ecs::BoxColliderComponent>(id.first);
			ecs::TransformComponent* transform = ecs->GetComponent<ecs::TransformComponent>(id.first);
			ecs::NameComponent* name = ecs->GetComponent<ecs::NameComponent>(id.first);

			if (!boxCollider || !transform || !name || name->entityTag != "Obstacle")
				continue;

			minBound = glm::min(minBound, boxCollider->box.bounds.min);
			maxBound = glm::max(maxBound, boxCollider->box.bounds.max);

			//if (boxCollider->box.bounds.min.x + transform->WorldTransformation.position.x < minBound.x) {
			//	minBound.x = boxCollider->box.bounds.min.x + transform->WorldTransformation.position.x;
			//}
			//if (boxCollider->box.bounds.min.y + transform->WorldTransformation.position.y < minBound.y) {
			//	minBound.y = boxCollider->box.bounds.min.y + transform->WorldTransformation.position.y;
			//}
			//if (boxCollider->box.bounds.min.z + transform->WorldTransformation.position.z < minBound.z) {
			//	minBound.z = boxCollider->box.bounds.min.z + transform->WorldTransformation.position.z;
			//}
			//if (boxCollider->box.bounds.max.x + transform->WorldTransformation.position.x > maxBound.x) {
			//	maxBound.x = boxCollider->box.bounds.max.x + transform->WorldTransformation.position.x;
			//}
			//if (boxCollider->box.bounds.max.y + transform->WorldTransformation.position.y > maxBound.y) {
			//	maxBound.y = boxCollider->box.bounds.max.y + transform->WorldTransformation.position.y;
			//}
			//if (boxCollider->box.bounds.max.z + transform->WorldTransformation.position.z > maxBound.z) {
			//	maxBound.z = boxCollider->box.bounds.max.z + transform->WorldTransformation.position.z;
			//}

			//std::cout << "MIN BOUND: " << boxCollider->box.bounds.min.x + transform->WorldTransformation.position.x << ", "
			//							<< boxCollider->box.bounds.min.y + transform->WorldTransformation.position.y << ", "
			//							<< boxCollider->box.bounds.min.z + transform->WorldTransformation.position.z << std::endl;

			//std::cout << "MAX Bound: " << boxCollider->box.bounds.max.x + transform->WorldTransformation.position.x << ", "
			//	<< boxCollider->box.bounds.max.y + transform->WorldTransformation.position.y << ", "
			//	<< boxCollider->box.bounds.max.z + transform->WorldTransformation.position.z << std::endl;
		}

		boundCenter.x = (minBound.x + maxBound.x) / 2.f;
		boundCenter.y = (minBound.y + maxBound.y) / 2.f;
		boundCenter.z = (minBound.z + maxBound.z) / 2.f;
		glm::vec3 boundSize = glm::vec3(1.f, 1.f, 1.f) * std::max(std::max(maxBound.x - minBound.x, maxBound.y - minBound.y), maxBound.z - minBound.z) * 0.5f;
		glm::vec3 boundMin = boundCenter - boundSize, boundMax = boundCenter + boundSize;

		bounds.center = boundCenter;
		bounds.size = boundSize;
		bounds.SetMinMax(boundMin, boundMax);

		//std::cout << "BOUNDS MIN: " << boundMin.x << ", " << boundMin.y << ", " << boundMin.z << std::endl;
		//std::cout << "BOUNDS MAX: " << boundMax.x << ", " << boundMax.y << ", " << boundMax.z << std::endl;
	}

	void Octree::GetEdges() {
		for (OctreeNode leaf : emptyLeaves) {
			for (OctreeNode otherLeaf : emptyLeaves) {
				if (leaf == otherLeaf)
					continue;

				Bounds otherBounds = otherLeaf.bounds;
				otherBounds.size *= 1.1f;
					if (leaf.bounds.Intersects(otherBounds)) {
					graph.AddEdge(&leaf, &otherLeaf);
				}
			}
		}
	}

	OctreeNode Octree::FindClosestNode(glm::vec3 position) {
		return FindClosestNode(root, position);
	}

	OctreeNode Octree::FindClosestNode(OctreeNode node, glm::vec3 position) {
		OctreeNode foundNode;

		for (int i = 0; i < node.children.size(); ++i) {
			if (node.children[i].bounds.Contains(position)) {
				if (node.children[i].IsLeaf()) {
					foundNode = node.children[i];
					break;
				}

				foundNode = FindClosestNode(node.children[i], position);
			}
		}

		return foundNode;
	}
}